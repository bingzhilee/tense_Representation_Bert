# -*- coding: utf-8 -*-
# Copyright(c) 2009 - present CNRS
# All rights reserved.

"""
Extract tense of the root word as the main tense of a sentence
(The conll format of PUD corpus is slightly different from that generated by Stanza)

"""
def ref_root_tense(deptree):
    tense_sent = []
    nb_tense = set(deptree.feats_tense)
    nb_tense.remove('_')
    nb_tense.remove('<root>')
    # the sentence don't have any tense cue
    if not nb_tense:
        tense_sent = ['UNK']
    else:
        idx = deptree.root_id
        # if the root has tense attrubute, it's a simple tense
        if deptree.feats_tense[idx] != '_':
            tense = deptree.feats_tense[idx].split('=')[1]
            if tense == 'Imp':
                tense_sent.append('passe')
            elif tense == 'Past':
                tense_sent.append('passe')
            else:
                tense_sent.append(tense)
        else:
            root_dep = deptree.gov2dep[idx]
            if root_dep:
                edge = [x for x in root_dep if deptree.xpos_tags[x[2]] == 'VBC']
                if len(edge) > 1:
                    edge = [x for x in edge if x[1] in ['aux:pass', 'aux:tense', 'cop', 'aux:caus']]
                if edge:
                    if edge[0][1] in ['aux:pass', 'cop', 'aux:caus']:
                        tense = deptree.feats_tense[edge[0][2]].split('=')[1]
                        if tense == 'Imp':
                            tense_sent.append('passe')
                        elif tense == 'Past':
                            tense_sent.append('passe')
                        else:
                            tense_sent.append(tense)
                    elif edge[0][1] == 'aux:tense':
                        tense = deptree.feats_tense[edge[0][2]].split('=')[1]
                        if tense in ['Pres', 'Imp', 'Past']:
                            tense_sent.append('passe')
                        else:
                            print(deptree)
                            print("erreur: manque de type de temps compos√©s")

                    else:
                        # - edge == 'conj' owing to root annotated errors
                        # - edge == parataxis, no root verb
                        # - ddge == acl:relcl, no root verb
                        tense_sent.append(normalise_tense(nb_tense))

                else:
                    # - root children dont have tense attribute
                    #  root grandson has tense attribute (2simple),
                    #     1 complexe due to annotated error, the generated tense is present, it turns out to be correct.
                    tense_sent.append(normalise_tense(nb_tense))
                    # print(deptree)
                    # print(normalise_tense(nb_tense))

            else:
                print(deptree)
                print("Error: root dosen't have children nodes")

    return tense_sent


# for sentences that we cant get root tense infos from root nor root deps
def normalise_tense(nb_tense):
    # here I don't take the case of that the root grandson has a complexe tense
    if len(nb_tense) == 1:
        return list(nb_tense)[0].split('=')[1]
    else:
        print("######2tenses: ", deptree)  # there's no tense conflict


