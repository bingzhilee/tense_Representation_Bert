# -*- coding: utf-8 -*-
# Copyright(c) 2009 - present CNRS
# All rights reserved.

"""
Extract tense of the root word as the main tense of a sentence
from conll file generated by stanza pipeline

"""

def root_tense(deptree):
    tense_sent = [ ]
    tense_list = list(deptree.feats_tense)
    while '_' in tense_list:
        tense_list.remove('_')
    tense_list.remove('<root>')
    # the sentence don't have any tense cue
    if not tense_list:
        tense_sent = ['UNK']
    # the major tense of a sentence is the root verb tense
    else:
        idx = deptree.root_id
        # if the root has tense attribute, then it's a simple tense
        if deptree.feats_tense[idx]!='_':
            tense = deptree.feats_tense[idx].split('=')[1]
            root_dep = deptree.gov2dep[idx]
            edge_verbInf = [x for x in root_dep if deptree.verb_form[x[2]]=="VerbForm=Inf"]
            if tense in ['Imp','Past']:
                tense_sent.append('Past')
            # capturer le futur proche avec aller(présent)+ verbe infinitive
            elif tense == 'Pres' and deptree.lemma[idx]=="aller" and edge_verbInf:
                tense_sent.append('Fut')
            else:
                tense_sent.append(tense)

        # when root doesn't have tense attribute
        else:
            root_dep = deptree.gov2dep[idx]
            if root_dep:
                # all the children of root who has tense attribute
                edge = [ x for x in root_dep if deptree.feats_tense[x[2]] != '_']
                # the four significant dependency labels
                if len(edge) > 1:
                    edge = [x for x in edge if x[1] in ['aux:pass','aux:tense','cop','aux:caus']]
                if edge:
                    #if len(edge)>1:
                    #    print(edge)
                    #    print(deptree) # no edge has 2 elements
                    tense = deptree.feats_tense[edge[0][2]].split('=')[1]
                    if edge[0][1] in ['aux:pass','cop','aux:caus']:
                        if tense in ['Imp','Past']:
                            tense_sent.append('Past')
                        else:
                            tense_sent.append(tense)

                    elif edge[0][1] == 'aux:tense':

                        # passé composé; plus-que-pafait; passé antérieur; futur antérieur;
                        # cond passé; impératif passé; sub.passé ou sub.plus-que-parfait  # les temps rares
                        # all the complexe tense should be put into category "Past"
                        tense_sent.append('Past')

                    else:
                        #- edge == 'conj' owing to root annotated errors
                        # - edge == parataxis, no root verb
                        # - ddge == acl:relcl, no root verb
                        tense_sent.append(normalise_tense(tense_list,deptree))


                else:
                    #- root children dont have tense attribute
                    #  root grandson has tense attribute (2simple),
                    #     1 complexe due to annotated error, the generated tense is present, it turns out to be correct.
                    tense_sent.append(normalise_tense(tense_list,deptree))

            else:
                print(deptree)
                print("Error: root dosen't have children nodes")

    return tense_sent

# for sentences that we can't get root tense infos neither from root nor from root deps
def normalise_tense(tense_list,deptree):

        tense_idx = [i for i in range(len(deptree.feats_tense)) if deptree.feats_tense[i] in ["Tense=Past","Tense=Fut","Tense=Pres","Tense=Imp"] ]
        tenses = [ ]
        for idx in tense_idx:
                if deptree.upos_tags[idx] == "AUX" and deptree.deprel[idx]=="aux:tense":
                        tense = "Past"

                else:
                        tense= deptree.feats_tense[idx].split('=')[1]
                        if tense in ['Imp','Past']:
                                tense = "Past"
                tenses.append(tense)
        if len(set(tenses)) == 1:
                gold_tense = tenses[0]

        else:
                gold_tense = "UNK"
                #print("tense-conflict: \n",deptree)
        return gold_tense



